class State{constructor(a,b,c=null,d=null){this.key=a,this.value=b,this.next=c,this.prev=d}}class LRUfactory{static fromString(a){let b=JSON.parse(a);return LRUfactory.fromJSON(b)}static fromJSON(a){var b=new LRU(a.limit),c=a.nodes;for(let d of c)b.write(d.key,d.value);return b}}class LRU{constructor(a=10){logger(this,"Creating new LRU cache"),this.size=0,this.limit=a,this.head=null,this.tail=null,this.cache={}}write(a,b){if(this.ensureLimit(),!this.head)this.head=this.tail=new State(a,b);else{var c=new State(a,b,this.head);this.head.prev=c,this.head=c}this.cache[a]=this.head,this.size++,logger(this,"New value stored into cache")}read(a){if(this.cache[a]){logger(this,"Key found in cache");var b=this.cache[a].value;return this.remove(a),b}return!1}ensureLimit(){this.size===this.limit&&(logger(this,"Cache maxed out, removing tail"),this.remove(this.tail.key))}remove(a){var b=this.cache[a];null===b.prev?this.head=b.next:b.prev.next=b.next,null===b.next?this.tail=b.prev:b.next.prev=b.prev,delete this.cache[a],this.size--,logger(this,"Old value removed from cache")}clear(){this.head=null,this.tail=null,this.size=0,this.cache={},logger(this,"Cache cleared")}forEach(a){for(var b=this.head,c=0;b;)a(b,c),b=b.next,c++}*[Symbol.iterator](){for(var a=this.head;a;)yield a,a=a.next}toJSON(){var a=[];for(let b of this)a.unshift({key:b.key,value:b.value});return{limit:this.limit,size:this.size,nodes:a}}}