class AbstractScorer{static async score(a){let b=this.scoreStatistics(a.statistics),c=this.scoreCache(a.cache),d=this.mergeScores([b].concat(c));return d}static scoreStatistics(){throw new Error("To be implemented")}static scoreCache(){throw new Error("To be implemented")}static mergeScores(){throw new Error("To be implemented")}}class RandomScorer extends AbstractScorer{static scoreStatistics(){return Math.random()}static scoreCache(){return[]}static mergeScores(a){return a[0]}}class DefaultScorer extends AbstractScorer{static scoreStatistics(a){return a.total_active_time+a.total_inactive_time+a.total_cached_time>=memoryManager.settings.scorer.min_active?Math.log(a.total_active_time)*a.total_active_time/(a.total_inactive_time+a.total_active_time)*Math.log(a.activated):1e15}static scoreCache(a){var b=[];return a.forEach(function(a){b.push(this.scoreStatistics(a.value.statistics))}),b}static mergeScores(a){for(var b=0,c=0;c<a.length;c++)b+=a[c]*Math.pow(memoryManager.settings.scorer.cached_decay,c);return b}}class Scorer{static score(a){return"random"===SCORER?RandomScorer.score(a):DefaultScorer.score(a)}}