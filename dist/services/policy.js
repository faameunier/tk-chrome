class PolicyManager{static async run(){let a=this.buildWindows();this.backfillRuns(a);let b=Object.keys(a),c=_.map(b,b=>this.runWindow(a,b)),d=await Promise.all(c),e=Date.now(),f=!1;for(var g=0;g<b.length;g++)d[g]&&(// The policy ran on the i-th window
memoryManager.settings.policy.last_policy_runs[b[g]]=e,f=!0);f&&(await memoryManager.save())}static buildWindows(){return _.groupBy(memoryManager.tabs,a=>a.windowId)}static backfillRuns(a){let b=Date.now(),c=Object.keys(memoryManager.settings.policy.last_policy_runs),d=Object.keys(a),e=_.difference(d,c);for(var f=0;f<e.length;f++)memoryManager.settings.policy.last_policy_runs[e[f]]=b}static async runWindow(a,b){let c=a[b];if(c.length>memoryManager.settings.policy.target_tabs&&this.exponentialTrigger(c,b))// if too many tabs
{// if we waited enough
// TODO filter tabs to removed protected ones.
let a=null;// await Promise.all(_.map(tabs, (tab) => Scorer.score(tab)))
return a=_.zip(_.map(c,a=>a.tabId),a),a.sort((a,b)=>a[1]>b[1]?1:-1),logger(this,b+" window scored: "+a.toString()),deleteMe=a.shift()[0],await this.killTab(deleteMe,_.find(c,a=>a.tabId===deleteMe)),!0}return!1}static async killTab(a,b){try{let c=new Promise((b,c)=>{chrome.tabs.remove(parseInt(a),function(){chrome.runtime.lastError?c("Tab not found"):b()})});// Deleting the tab will trigger all cleaning actions in memoryManager through the onRemoved trigger.
// making a simple json copy, could be even simpler.
await c,memoryManager.closed_history.push(copy(b)),logger(this,"Tab "+a+" killed by policy")}catch(b){logger(this,"Tab "+a+" not found")}}static exponentialTrigger(a,b){let c=a.length,d=memoryManager.settings.policy.last_policy_runs[b];return Date.now()-memoryManager.settings.policy.last_policy_runs[b]>=memoryManager.settings.policy.min_time*Math.pow(memoryManager.settings.policy.decay,Math.max(0,c-memoryManager.settings.policy.target_tabs))}}